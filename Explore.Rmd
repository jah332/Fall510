---
title: "Explore"
author: "John Horton"
date: "October 21, 2015"
output: html_document
---

Setup:

```{r}
#Load required packages
require(ggplot2)
require(grid)
require(plyr)

#Load diamonds and mtcars dataframes
data(diamonds)
data(mtcars)

#Add logical column to diamonds dataframe
  #Here we generate a vector of random values between 0 and 1, generating a random value for each row in the user's dataframe
  randVec <- runif(nrow(diamonds),0.0,1.0)
  #We initialize logicVec as an empty vector
  logicVec <- c()
  #The variable pctTrue represents the percentage of TRUE entries in the new logical column of the user's dataframe; we use 0.4375 as per Professor G's posted interpretation of the logical column
  pctTrue <- 0.4375
  #We loop through each value in randVec so we may assign corresponding values to logicVec
  for(i in 1:length(randVec)){
    #If the value randVec[i] is less than pctTrue, we add a TRUE to logicVec; otherwise, we add a FALSE to logicVec
    if(randVec[i] <= pctTrue){
      logicVec[i] <- TRUE
    }
    else{
      logicVec[i] <- FALSE
    }
  }
  #We add logicVec to diamonds
  diamonds$logical <- logicVec
```

Explore Function:

This function takes a dataframe, a vector of histogram bin sizes, and a correlation threshold from the user and:
1) Plots count and density histograms for each of the numeric variables in the user's    dataframe, first with a default bin size and then with bin sizes as specified in     the user's vector.
2) Plots bar graphs for each of the categorical variables in the user's dataframe.
3) Returns a list of the following:
  a: Frequency tables for all categorical variables in the user's dataframe
  b: Statistical summary tables for all numeric variables inthe user's dataframe
  c: A table containing the R-square value for each pair of numeric variables in the      user's dataframe
  d: A table containing the correlation coefficient for each pair of numeric              variables in the user's dataframe. Pairs are only included if their correlation      coefficient is greater than the threshold input by the user

Parameters:
 - dataFrame: the dataframe input by the user
 - binSizes: a vector of histogram bin sizes input by the user
 - corrVal: the correlation threshold input by the user, as described above
 
Return:
 - returnList: an R list object containing all of the plots and tables described above

```{r}
Explore <- function(dataFrame,binSizes,corrVal){
  ##############################################################################
  ### Question 1 ###
  ##############################################################################
  
  #We first isolate the numeric columns in the user's dataframe
  numFrame <- dataFrame[sapply(dataFrame,is.numeric)]
  #We initialize numPlots as an empty list
  numPlots <- list()
  #The index variable k is initialized to 1; k will correspond to the total number of plots in numPlots
  k <- 1
  #If there are numeric columns in the user's dataframe, we proceed as follows
  if(ncol(numFrame)>0){
  #We loop through each of the columns in numFrame so that we may plot each of the numeric columns in the user's dataframe
  for(i in 1:ncol(numFrame)){
    #We pull the title of the ith column, so we may avoid calling a function in our aes_string call below
    colName <- colnames(numFrame)[i]
    #We pull the mean of the ith column, so that we may avoid calling a function in our geom_vline call below
    colMean <- mean(numFrame[,i])
    #First, we create two histograms for each variable (one for count, another for density) with default bin sizes. These default plots are generated as the bin sizes input by the user may all be unreasonably small or large for some variables, depending on their range.
    #Plots are generated by calling ggplot along with geom_histogram (to plot the histogram) and geom_vline (to plot the vertical line at the variable's mean)
    numPlots[[k]] <- ggplot(numFrame,aes_string(colName)) +                                 geom_histogram(fill="blue") + geom_vline(xintercept=colMean,color="red")
    #After each plot, we increase k by 1 so that we may move on to the next plot
    k <- k+1
    numPlots[[k]] <- ggplot(numFrame,aes_string(colName)) +                               geom_histogram(aes(y=..density..),fill="blue") +                                      geom_vline(xintercept=colMean,color="red")
    k <- k+1
    #Now that the default plots for the current variable have been generated, we loop through each of the bin sizes input by the user
    for(j in 1:length(binSizes)){
      #binWidth stores the current bin size
      binWidth = binSizes[j]
      #Plots awre generated as above, now adding the binwidth specification
      numPlots[[k]] <- ggplot(numFrame,aes_string(colName)) +                                 geom_histogram(binwidth=binWidth,fill="blue") +                                       geom_vline(xintercept=colMean,color="red")
      k <- k+1
      numPlots[[k]] <- ggplot(numFrame,aes_string(colName)) +                               geom_histogram(aes(y=..density..),binwidth=binWidth,fill="blue") +                    geom_vline(xintercept=colMean,color="red")
      k <- k+1
    }
  }
  }
  
  ##############################################################################
  ### Question 2 ###
  ##############################################################################
  
  #We isolate the logical and factor columns in the user's dataframe
  logFrame <- dataFrame[sapply(dataFrame,is.logical)]
  facFrame <- dataFrame[sapply(dataFrame,is.factor)]
  #We now combine all of the logical and factor columns to get a dataframe containing all of the categorical variables in the user's dataframe
  catFrame <- data.frame(logFrame,facFrame)
  #We initialize catPlots as an empty list
  catPlots <- list()
  #If there are categorical columns in the user's dataframe, we proceed as follows
  if(ncol(catFrame)>0){
  #We loop through each of the columns in catFrame
  for(i in 1:ncol(catFrame)){
    #xLabel stores the name of the column to be plotted, so we may avoid calling a function inside our aes call below
    xLabel <- colnames(catFrame)[i]
    #We call ggplot and geom_bar to produce a bar plot for each column in catFrame
    #Each plot is then added to catPlots so that all plots may be returned
    catPlots[[i]] <- ggplot(catFrame,aes_string(xLabel))+geom_bar(fill="grey")
  }
  }
  
  ##############################################################################
  ### Question 3 ###
  ##############################################################################
  
  #The vector corrTitle, which will hold the titles of each pair of numeric columns, is initialized as an empty vector
  #Each value in this vector will be of the form 'col1-col2', where col1 and col2 are the titles of column 1 and column 2
  corrTitle <- c()
  #The vector corrValue, which will hold the Pearson correlation coefficient for each pair of numeric columns, is initialized as an empty vector
  corrValue <- c()
  #The index variable k is reset to 1; k now corresponds to the total number of non-repeating pairs of numeric columns in dataFrame
  k <- 1
  #We loop through each column in numFrame (as created above) so that we may take the correlation between that column and the next
  #If there are numeric columns in the user's dataframe, we proceed as follows
  if(ncol(numFrame)>0){
  for(i in 1:(ncol(numFrame)-1)){
    #We start our next loop at i+1, so that we do not repeat pairs of columns
    #Starting our loop at i+1 also avoids taking unneccessary correlations between a column and itself, i.e. we do not take the correlation between carat and carat, as that is obviously 1
    for(j in (i+1):(ncol(numFrame))){
      #We take the title of the current pair of columns
      corrTitle[k] <- paste(colnames(numFrame)[i],"-",colnames(numFrame)[j],sep="")
      #We take the correlation of the current pair of columns
      corrValue[k] <- cor(numFrame[,i],numFrame[,j],method="pearson")
      #We increase k by 1, as we now consider the next pair
      k <- k+1
    }
  }
  }
  #We initialize corrFrame as an empty dataframe with one row for each pair of columns taken above
  corrFrame <- data.frame(matrix(ncol=0,nrow=k-1))
  #We insert two new columns to corrFrame, one for the title of each pair of columns, another for the r-square for each pair of columns
  corrFrame["Columns"] <- corrTitle
  corrFrame["R-Square"] <- corrValue^2
  #Please note that this table will be returned on its own, but only later on when it is required for Question 4, so as not to be redundant
  
  ##############################################################################
  ### Question 4 ###
  ##############################################################################
  
  #We initialize summaryTables as an empty list
  summaryTables <- list()
  #The index variable k is reset to 1
  k <- 1
  #If there are categorical columns in the user's dataframe, we proceed as follows
  if(ncol(catFrame)>0){
  #We loop through each of the columns in catFrame (as created above)
  for(i in 1:ncol(catFrame)){
    #varName stores the name of the column for which we are taking the next frequency table, so we may avoid calling a function inside our count call below
    varName <- colnames(catFrame)[i]
    #We use the count function from the plyr package to construct frequency tables for each column in catFrame
    #The count function returns the frequency tables as dataframes, each of which is stored in summaryTables so that all tables may be returned 
    summaryTables[[k]] <- count(catFrame,varName)
    #We increase k by 1, as we now consider the next categorical variable
    k <- k+1
  }
  }
  
  #If there are numeric columns in the user's dataframe, we proceed as follows
  if(ncol(numFrame)>0){
  #We call the summary function to generate statistical summaries for each column in numFrame. All tables are added at once.
  summaryTables[[k]] <- summary(numFrame)
  #We increase k by 1, as we now consider the next object to be added to summaryTables
  k <- k+1
  }
  
  #We add corrFrame (as created above) to summaryTables
  summaryTables[[k]] <- corrFrame
  #We increase k by 1, as we now consider the next object to be added to summaryTables
  k <- k+1
  
  #The vector corrTitle, which will hold the titles of each pair of numeric columns, is initialized as an empty vector
  #Each value in this vector will be of the form 'col1-col2', where col1 and col2 are the titles of column 1 and column 2
  corrTitle <- c()
  #The vector corrValue, which will hold the Pearson correlation coefficient for each pair of numeric columns, is initialized as an empty vector
  corrValue <- c()
  #The index variable n is initialized to 1; n corresponds to the total number of non-repeating pairs of numeric columns in dataFrame
  n <- 1
  #The index variable m is initialized to 1; m corresponds to the total number of non-repeating pairs of numeric columns in dataFrame with a correlation greater in absolute value than our threshold
  m <- 1
  #If there are numeric columns in the user's dataframe, we proceed as follows
  if(ncol(numFrame)>0){
  #We loop through each column in numFrame (as created above) so that we may take the correlation between that column and the next
  for(i in 1:(ncol(numFrame)-1)){
    #We start our next loop at i+1, so that we do not repeat pairs of columns
    #Starting our loop at i+1 also avoids taking unneccessary correlations between a column and itself, i.e. we do not take the correlation between carat and carat, as that is obviously 1
    for(j in (i+1):(ncol(numFrame))){
      #We only perform the following steps for pairs of columns with a correlation coefficient that is greater in absolute value than our threshold
      if(abs(cor(numFrame[,i],numFrame[,j],method="pearson"))>corrVal){
        #We take the title of the current pair of columns
        corrTitle[m] <- paste(colnames(numFrame)[i],"-",colnames(numFrame)[j],sep="")
        #We take the correlation of the current pair of columns
        corrValue[m] <- cor(numFrame[,i],numFrame[,j],method="pearson")
        #We increase m by 1, as we now consider the next pair of variables with a high correlation
        m <- m+1
      }
      #We increase n by 1, as we now consider the next pair
      n <- n+1
    }
  }
  }
  #We reset corrFrame to an empty dataframe with one row for each pair of columns taken above with a correlation coefficient greater in absolute value than our threshold
  corrFrame <- data.frame(matrix(ncol=0,nrow=m-1))
  #We insert two new columns to our return dataframe, one for the title of each pair of columns, another for the correlation of each pair of columns
  corrFrame["Columns"] <- corrTitle
  corrFrame["Correlation"] <- corrValue
  #The new corrFrame is added to summaryTables
  summaryTables[[k]] <- corrFrame
  
#returnList stores all of the objects created by the function; the histograms requested in Question 1 are stored in numPlots, the bar graphs requested in Question 2 are stored in catPlots, and all of the tables requested by Questions 3 and 4 are stored in summaryTables
returnList <- list(numPlots,catPlots,summaryTables)
return(returnList)
}

#Tests the function
Explore(diamonds,c(5,20,50),0.25)
Explore(mtcars,c(5,20,50),0.25)
```

